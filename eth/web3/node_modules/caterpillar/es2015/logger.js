'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* @flow */
var _require = require('extendr');

var extend = _require.extend;
var deep = _require.deep;

var _require2 = require('stream');

var PassThrough = _require2.PassThrough;

/* ::
declare class LongError extends Error {
  __previous: ?LongError;
  __previous__: ?LongError;
}
type levelInfo = {
	levelNumber: number,
	levelName: string
};
type lineInfo = {
	line: number,
	method: string,
	file: string
};
type logEntry = {
	date: string,
	args: Array<any>
};
*/

/**
Logger.
This is what we write to.
It extends from PassThrough and not transform.
If you are piping / writing directly to the logger, make sure it corresponds to the correct entry format (as described in `log`).

@example <caption>Creation</caption>
// Via class
const Logger = require('caterpillar').Logger
const logger = new Logger()
// Via create helper
const logger = Logger.create()
// Via create alias
const logger = require('caterpillar').create()

@extends stream.PassThrough
*/

var Logger = function (_PassThrough) {
	_inherits(Logger, _PassThrough);

	_createClass(Logger, [{
		key: 'getInitialConfig',


		// ===================================
		// Generic Differences
		// This code is shared but different between Logger and Transform

		/**
  Get the initial configuration option.
  Default log levels are compliant with http://www.faqs.org/rfcs/rfc3164.html
  @returns {Object}
  */
		value: function getInitialConfig() {
			return {
				lineOffset: 0,
				levels: {
					emergency: 0,
					alert: 1,
					critical: 2,
					error: 3,
					warning: 4,
					notice: 5,
					info: 6,
					debug: 7,

					emerg: 0,
					crit: 2,
					err: 3,
					warn: 4,
					note: 5,

					'default': 6
				}
			};
		}

		/**
  Alternative way of creating an instance of the class without having to use the `new` keyword.
  Useful when creating the class directly from `require` statements.
  @static
  @param {...*} args
  @returns {Logger}
  */

	}], [{
		key: 'create',
		value: function create() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(this, [null].concat(args)))();
		}

		// ===================================
		// Generic
		// This code is shared between Logger and Transform

		/**
  Construct our class and pass the arguments over to `setConfig`
  @params {...*} args
  */

	}]);

	function Logger() /* :Array<any> */{
		var _ref;

		_classCallCheck(this, Logger);

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		var _this = _possibleConstructorReturn(this, (_ref = Logger.__proto__ || Object.getPrototypeOf(Logger)).call.apply(_ref, [this].concat(args)));

		_this._config = _this.getInitialConfig();
		_this.setConfig.apply(_this, args);
		return _this;
	}

	/**
 Internal configuration object
 @property {Object} _config
 @private
 */
	/* :: _config:Object; */

	/**
 Get the current configuration object for this instance.
 @returns {Object}
 */


	_createClass(Logger, [{
		key: 'getConfig',
		value: function getConfig() /* :Object */{
			return this._config;
		}

		/**
  Apply the specified configurations to this instance's configuration via deep merging.
  @example
  setConfig({a: 1}, {b: 2})
  getConfig()  // {a: 1, b: 2}
  @param {...Array<Object>} configs
  @returns {this}
  */

	}, {
		key: 'setConfig',
		value: function setConfig() /* :Array<Object> */ /* :this */{
			for (var _len3 = arguments.length, configs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				configs[_key3] = arguments[_key3];
			}

			deep.apply(undefined, [this._config].concat(configs));
			this.emit.apply(this, ['config'].concat(configs));
			return this;
		}

		/**
  Pipe this data to some other writable stream.
  If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
  @param {stream.Writable} child stream to be piped to
  @returns {stream.Writable} the result of the pipe operation
  */

	}, {
		key: 'pipe',
		value: function pipe(child /* :Object */) /* :any */{
			var _this2 = this;

			if (child.setConfig) {
				(function () {
					child.setConfig(_this2.getConfig());
					var listener = child.setConfig.bind(child);
					_this2.on('config', listener);
					child.once('close', function () {
						return _this2.removeListener('config', listener);
					});
				})();
			}
			return _get(Logger.prototype.__proto__ || Object.getPrototypeOf(Logger.prototype), 'pipe', this).call(this, child);
		}

		// ===================================
		// Logger

		/**
  Receive a level name and return the level number
  @param {string} name
  @returns {number}
  @throws {Error} will throw an error if no result was found
  */

	}, {
		key: 'getLevelNumber',
		value: function getLevelNumber(name /* :string */) /* :number */{
			var _getConfig = this.getConfig();

			var levels = _getConfig.levels;

			if (levels[name] == null) {
				throw new Error('No level number was found for the level name: ' + name);
			} else {
				return levels[name];
			}
		}

		/**
  Receive a level number and return the level name
  @param {number} number
  @returns {string}
  @throws {Error} will throw an error if returned empty handed
  */

	}, {
		key: 'getLevelName',
		value: function getLevelName(number /* :number */) /* :string */{
			var _getConfig2 = this.getConfig();

			var levels = _getConfig2.levels;

			// Try to return the levelName

			for (var name in levels) {
				if (levels.hasOwnProperty(name)) {
					var value = levels[name];
					if (value === number) {
						return name;
					}
				}
			}

			// Return
			throw new Error('No level name was found for the level number: ' + number);
		}

		/**
  Receive either the level name or number and return the combination.
  @example <caption>Input</caption>
  logger.getLevelInfo('note')
  @example <caption>Result</caption>
  {
  	"levelNumber": 5,
  	"levelName": "notice"
  }
  @param {string|number} level
  @returns {Object}
  @throws {Error} will throw an error if returned empty handed
  */

	}, {
		key: 'getLevelInfo',
		value: function getLevelInfo(level /* :string|number */) /* :levelInfo */{
			if (typeof level === 'string') {
				var levelNumber = this.getLevelNumber(level); // will throw if not found
				var levelName = this.getLevelName(levelNumber); // name could be shortened, so get the expanded name
				return { levelNumber: levelNumber, levelName: levelName };
			} else if (typeof level === 'number') {
				var _levelName = this.getLevelName(level); // will throw if not found
				return { levelNumber: level, levelName: _levelName };
			} else {
				throw new Error('Unknown level type: ' + (typeof level === 'undefined' ? 'undefined' : _typeof(level)) + ' for ' + level);
			}
		}

		/**
  The current line info of whatever called this.
  @example <caption>Input</caption>
  logger.getLineInfo()
  @example <caption>Result</caption>
  {
  	"line": "60",
  	"method": "Object.<anonymous>",
  	"file": "/Users/balupton/some-project/calling-file.js"
  }
  @returns {Object}
  @throws {Error} will throw an error if returned empty handed
  */

	}, {
		key: 'getLineInfo',
		value: function getLineInfo() /* :lineInfo */{
			// Prepare
			var offset = this.getConfig().lineOffset;
			var result = {
				line: -1,
				method: 'unknown',
				file: 'unknown'
			};

			try {
				// Create an error
				var err /* :LongError */ = new Error() /* :any */;
				var stack = void 0,
				    lines = void 0;

				// And attempt to retrieve it's stack
				// https://github.com/winstonjs/winston/issues/401#issuecomment-61913086
				try {
					stack = err.stack;
				} catch (error1) {
					try {
						var previous = err.__previous__ || err.__previous;
						stack = previous && previous.stack;
					} catch (error2) {
						stack = null;
					}
				}

				// Handle different stack formats
				if (stack) {
					if (Array.isArray(stack)) {
						lines = Array(stack);
					} else {
						lines = stack.toString().split('\n');
					}
				} else {
					lines = [];
				}

				// Handle different line formats
				lines = lines
				// Ensure each line item is a string
				.map(function (line) {
					return (line || '').toString();
				})
				// Filter out empty line items
				.filter(function (line) {
					return line.length !== 0;
				});

				// Parse our lines
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var line = _step.value;

						if (line.indexOf(__dirname) !== -1 || line.indexOf(' at ') === -1) {
							continue;
						}

						if (offset !== 0) {
							--offset;
							continue;
						}

						var parts = line.split(':');
						if (parts.length >= 2) {
							if (parts[0].indexOf('(') === -1) {
								result.method = 'unknown';
								result.file = parts[0].replace(/^.+?\s+at\s+/, '');
							} else {
								result.method = parts[0].replace(/^.+?\s+at\s+/, '').replace(/\s+\(.+$/, '');
								result.file = parts[0].replace(/^.+?\(/, '');
							}
							result.line = Number(parts[1]);
							break;
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			} catch (err) {
				throw new Error('Caterpillar.getLineInfo: Failed to parse the error stack: ' + err);
			}

			// Return
			return result;
		}

		/**
  Log the arguments into the logger stream as formatted data with debugging information.
  	@example <caption>Inputs</caption>
  logger.log('note', 'this is working swell')
  logger.log('this', 'worked', 'swell')
  	@example <caption>Results</caption>
  {
  	"args": ["this is working swell"],
  	"date": "2013-04-25T10:18:25.722Z",
  	"levelNumber": 5,
  	"levelName": "notice",
  	"line": "59",
  	"method": "Object.<anonymous>",
  	"file": "/Users/balupton/some-project/calling-file.js"
  }
  {
  	"args": ["this", "worked", "well"],
  	"date": "2013-04-25T10:18:26.539Z",
  	"levelNumber": 6,
  	"levelName": "info",
  	"line": "60",
  	"method": "Object.<anonymous>",
  	"file": "/Users/balupton/some-project/calling-file.js"
  }
  	@param {...*} args
  @returns {Object}
  */

	}, {
		key: 'log',
		value: function log() /* :Array<any> */ /* :this */{
			for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				args[_key4] = arguments[_key4];
			}

			var date = new Date().toISOString();
			var lineInfo = this.getLineInfo();

			var level /* :string|number */ = args.shift();
			var levelInfo = void 0;
			try {
				levelInfo = this.getLevelInfo(level);
			} catch (err) {
				// if it threw (level was not a valid name or number), then use the default level
				levelInfo = this.getLevelInfo('default');
				args.unshift(level);
			}

			// Create the entry by mashing them together
			var entry /* :logEntry */ = extend({ date: date, args: args }, levelInfo, lineInfo);

			// Write the arguments as an entry to be transformed by our format
			this.write(JSON.stringify(entry));

			// Chain
			return this;
		}
	}]);

	return Logger;
}(PassThrough);

// Export


module.exports = Logger;