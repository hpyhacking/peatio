'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* @flow */
var _require = require('extendr');

var deep = _require.deep;

var _Transform = require('stream').Transform;

/**
Transform.
This is a helper for our transforms to be able to process the written log data more easily.
All the need to do is extend this class and add their own `format` method.

@example
class Pretty extends require('caterpillar').Transform {
	format (entry) {
		return require('util').inspect(entry, {colors: true})
	}
}
require('caterpillar').create()
	.pipe(Pretty.create())
	.pipe(process.stdout)
	.log('note', 'cool times', 5)

@extends stream.Transform
*/

var Transform = function (_Transform2) {
	_inherits(Transform, _Transform2);

	_createClass(Transform, [{
		key: 'getInitialConfig',


		// ===================================
		// Generic Differences
		// This code is shared but different between Logger and Transform

		/**
  Get the initial configuration option.
  Use this to add default/initial configuration to your class.
  @returns {Object}
  */
		value: function getInitialConfig() /* :Object */{
			return {};
		}

		/**
  Alternative way of creating an instance of the class without having to use the `new` keyword.
  Useful when creating the class directly from `require` statements.
  @static
  @param {...*} args
  @returns {Transform}
  */

	}], [{
		key: 'create',
		value: function create() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return new (Function.prototype.bind.apply(this, [null].concat(args)))();
		}

		// ===================================
		// Generic
		// This code is shared between Logger and Transform

		/**
  Construct our class and pass the arguments over to `setConfig`
  @params {...*} args
  */

	}]);

	function Transform() /* :Array<any> */{
		var _ref;

		_classCallCheck(this, Transform);

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		var _this = _possibleConstructorReturn(this, (_ref = Transform.__proto__ || Object.getPrototypeOf(Transform)).call.apply(_ref, [this].concat(args)));

		_this._config = _this.getInitialConfig();
		_this.setConfig.apply(_this, args);
		return _this;
	}

	/**
 Internal configuration object
 @property {Object} _config
 @private
 */
	/* :: _config:Object; */

	/**
 Get the current configuration object for this instance.
 @returns {Object}
 */


	_createClass(Transform, [{
		key: 'getConfig',
		value: function getConfig() /* :Object */{
			return this._config;
		}

		/**
  Apply the specified configurations to this instance's configuration via deep merging.
  @example
  setConfig({a: 1}, {b: 2})
  getConfig()  // {a: 1, b: 2}
  @param {...Array<Object>} configs
  @returns {this}
  */

	}, {
		key: 'setConfig',
		value: function setConfig() /* :Array<Object> */ /* :this */{
			for (var _len3 = arguments.length, configs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				configs[_key3] = arguments[_key3];
			}

			deep.apply(undefined, [this._config].concat(configs));
			this.emit.apply(this, ['config'].concat(configs));
			return this;
		}

		/**
  Pipe this data to some other writable stream.
  If the child stream also has a `setConfig` method, we will ensure the childs configuration is kept consistent with parents.
  @param {stream.Writable} child stream to be piped to
  @returns {stream.Writable} the result of the pipe operation
  */

	}, {
		key: 'pipe',
		value: function pipe(child /* :Object */) /* :any */{
			var _this2 = this;

			if (child.setConfig) {
				(function () {
					child.setConfig(_this2.getConfig());
					var listener = child.setConfig.bind(child);
					_this2.on('config', listener);
					child.once('close', function () {
						return _this2.removeListener('config', listener);
					});
				})();
			}
			return _get(Transform.prototype.__proto__ || Object.getPrototypeOf(Transform.prototype), 'pipe', this).call(this, child);
		}

		// ===================================
		// Transform

		/**
  Transform the written buffer into data we can format
  @private
  @param {Buffer|string} chunk
  @param {string} encoding
  @param {function} next
  @returns {undefined}
  */

	}, {
		key: '_transform',
		value: function _transform(chunk /* :Buffer|string */, encoding /* :string */, next /* :function */) /* :void */{
			var message = chunk.toString();

			try {
				message = this.format(message);
			} catch (err) {
				return next(err);
			}

			if (message && (typeof message === 'undefined' ? 'undefined' : _typeof(message)) === 'object') {
				message = JSON.stringify(message);
			}

			return next(null, message);
		}

		/**
  Format the written data into whatever we want.
  Here is where our transformers work with the written data to enhance it.
  @param {string} message
  @returns {*}
  */

	}, {
		key: 'format',
		value: function format(message /* :string */) /* :mixed */{
			return message;
		}
	}]);

	return Transform;
}(_Transform);

// Export


module.exports = Transform;